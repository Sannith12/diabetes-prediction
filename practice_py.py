# -*- coding: utf-8 -*-
"""practice.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VR1lSD7WmUNwQCbqNEfcx-L-dY_y9No-

**Importing the required libraries**
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()
import missingno as msno
from mlxtend.plotting import plot_decision_regions
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn import metrics
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report

"""**Reading the dataset by specifying location using pandas**

"""

d_set=pd.read_csv('/content/diabetes.csv')
d_set.head()

"""**Exploratory Data Analysis**

Identify Different Columns
"""

d_set.columns

"""Information Regarding the dataset"""

d_set.info()

"""Description regarding dataset"""

d_set.describe()

"""Checking NULL Values"""

d_set.isnull().head()

"""Number of NULL Values in Dataset"""

d_set.isnull().sum()

"""Replacing 0 by NAN"""

d_copy=d_set.copy(deep=True)
d_copy[['Glucose', 'BloodPressure', 'SkinThickness', 'Insulin',
       'BMI']]=d_copy[['Glucose', 'BloodPressure', 'SkinThickness', 'Insulin',
       'BMI']].replace(0,np.NaN)
print(d_copy.isnull().sum())

"""**Data Visualization**"""

p=d_set.hist(figsize=(20,20))

"""Imputing mean value to all the missing values of respective columns"""

d_copy['Glucose'].fillna(d_copy['Glucose'].mean(),inplace = True)
d_copy['BloodPressure'].fillna(d_copy['BloodPressure'].mean(),inplace = True)
d_copy['SkinThickness'].fillna(d_copy['SkinThickness'].mean(),inplace = True)
d_copy['Insulin'].fillna(d_copy['Insulin'].mean(),inplace = True)
d_copy['BMI'].fillna(d_copy['BMI'].mean(),inplace = True)

"""plotting after removing the NAN values"""

p=d_copy.hist(figsize=(20,20))

"""Plotting Null Count Analysis Plot"""

p=msno.bar(d_set)

"""Correlation between all the features"""

plt.figure(figsize=(15,15))
p=sns.heatmap(d_set.corr(),annot=True,cmap='RdYlGn')

"""**Scaling the Data**"""

d_copy.head()

"""After Standard Scaling"""

sc_X = StandardScaler()
X =  pd.DataFrame(sc_X.fit_transform(d_copy.drop(["Outcome"],axis = 1),), columns=['Pregnancies', 
'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI', 'DiabetesPedigreeFunction', 'Age'])
X.head()

"""Exploring  target column(Outcome)"""

y=d_copy.Outcome
y

"""**Model Building**
splitting the dataset
"""

X=d_set.drop('Outcome',axis=1)
y=d_set['Outcome']

"""Splitting the data into training and testing data from sklearn.model_selection"""

from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test=train_test_split(X,y,random_state=0,test_size=0.2)

"""**Random Forest**"""

from sklearn.ensemble import RandomForestClassifier
rf=RandomForestClassifier()
rf.fit(X_train,y_train)

"""Accuracy Score for Random Forest"""

from sklearn import metrics
predictions=rf.predict(X_test)
print("Accuracy Score =",format(metrics.accuracy_score(y_test,predictions)))

"""Classification Report and Confusion Matrix"""

from sklearn.metrics import classification_report, confusion_matrix
print(confusion_matrix(y_test,predictions))
print(classification_report(y_test,predictions))

"""**K Nearest Neighbors**"""

from sklearn.neighbors import KNeighborsClassifier
knc=KNeighborsClassifier()
knc.fit(X_train,y_train)

from sklearn import metrics
p = knc.predict(X_test)
print("Accuracy_Score=",format(metrics.accuracy_score(y_test,p)))

"""Classification Report and Confusion Matrix"""

from sklearn.metrics import classification_report, confusion_matrix
print(confusion_matrix(y_test,p))
print(classification_report(y_test,p))

"""**Support Vector Machine(SVM)**"""

from sklearn.svm import  SVC
s=SVC()
s.fit(X_train,y_train)

from sklearn import metrics
s_pred=s.predict(X_test)
print("Accuracy_score=",format(metrics.accuracy_score(y_test,s_pred)))

"""Classification Report and Confusion Matrix"""

from sklearn.metrics import classification_report, confusion_matrix
print(confusion_matrix(y_test,s_pred))
print(classification_report(y_test,s_pred))